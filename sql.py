# -*- coding: utf-8 -*-
"""sql.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oZ_X0RynoDoWHA4hF5D9zeLm2kJgYkKs
"""

from pyeuclid.formalization.relation import *
from pyeuclid.engine.inference_rule import *

import inspect
import sqlite3
import os

sqliteConnection = sqlite3.connect("sql.db")

cursor = sqliteConnection.cursor()

def create_table(name, n_points, unionfind=False):
    query = ", ".join([f"p{i} CHAR(10) NOT NULL" for i in range(n_points)])
    query += ", "
    query += ", ".join([f"FOREIGN KEY(p{i}) REFERENCES points(name)" for i in range(n_points)])
    if unionfind:
        query += f", component INT"
    primary = ", ".join([f"p{i}" for i in range(n_points)])
    query += f" PRIMARY KEY ({primary})"
    query = f"CREATE TABLE {name} ({query});"
    cursor.execute(query)
    return query


points = """ CREATE TABLE points (
            name CHAR(10) PRIMARY KEY NOT NULL
        ); """
cursor.execute(points)

for name, rel in relations.items():
    args = inspect.getfullargspec(rel)
    npoints = len(args[0]) - 1
    create_table(f"`{name}`", npoints)

create_table("angle", 3)
create_table("angle_sum", 6)
create_table("length", 2)
create_table("length_ratio", 4)


cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
cursor.fetchall()

cursor.execute("DELETE FROM parallel;")
cursor.fetchall()


def insert_relation(relation: Relation):
    table = type(relation).__name__.lower()
    points = relation.get_points()
    cols = ",".join([f"p{i}" for i in range(len(points))])
    values = ",".join([f"'{item}'" for item in points])
    for point in points:
        query = f"INSERT OR IGNORE INTO points (name) VALUES ('{point}');"
        cursor.execute(query)
    query = f"""
    INSERT OR IGNORE INTO {table} ({cols})
    VALUES ({values});
    """
    cursor.execute(query)
    
def generate_query(inference: InferenceRule):
    query = "SELECT "
    formal_points = inspect.getfullargspec(inference)[0][1:]
    formal_points = [Point(item) for item in formal_points]
    condition = inference(*formal_points).condition()
    for point in formal_points:
        query += f"{point}.name, "
    query = query[:-2] + " "
    query += "FROM "
    for point in formal_points:
        query += f"points {point}, "
    query = query[:-2]
    where = "WHERE"
    for i, relation in enumerate(condition):
        points = relation.get_points()
        if isinstance(relation, Lt):
            assert not relation.negated
            query += f" {where} {points[0]}.name < {points[1]}.name"
            where = "AND"
        elif isinstance(relation, Equal):
            assert relation.negated
            query += f" {where} {points[0]}.name != {points[1]}.name"
            where = "AND"
        else:
            table = type(relation).__name__.lower()
            assert table in relations
            query += f" INNER JOIN {table} r{i} ON "
            if hasattr(relation, "permutations"):
                permutations = relation.permutations()
            else:
                permutations = [points]
            permutation_clauses = []
            for permutation in permutations:
                point_atoms = []
                for j, point in enumerate(permutation):
                    point_atoms.append(f"{point}.name = r{i}.p{j}")
                permutation_clauses.append(f"({" AND ".join(point_atoms)})")
            query += " OR ".join(permutation_clauses)
    print(query)
    cursor.execute(query)
    results = cursor.fetchall()
    return results


if __name__ == "__main__":
    try:
        a, b, c, d = Point("a"), Point("b"), Point("c"), Point("d")
        insert_relation(Parallel(a, b, b, c))
        cursor.execute("SELECT * FROM parallel;")
        results = cursor.fetchall()
        print(results)
        results = generate_query(AlphaGeometry29)
        print(results)
    finally:
        sqliteConnection.close()
        os.remove("sql.db")